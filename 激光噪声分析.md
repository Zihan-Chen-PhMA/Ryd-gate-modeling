
# 白噪声和伺服噪声
伺服噪声的功率谱函数分别为：
$S_{\delta \nu} = h_0 + \frac{s_g f_g^2}{\sqrt{8\pi} \sigma_g} e^{\frac{-(f - f_g)^2}{2\sigma_g^2}} + \frac{s_g f_g^2}{\sqrt{8\pi} \sigma_g}  e^{\frac{-(f + f_g)^2}{2\sigma_g^2}}$
当$h_g = 0$,成为白噪声, 此外可能有多个gauss Bump存在。
数据的典型值:对$\Omega = 2\pi \times1 MHz$的激光，设置$h_0 = 0 Hz, f_g \in (0.1,4) \times \frac{\Omega}{2\pi},\sigma_g = 1400 Hz, s_g = \frac{\sqrt{8\pi } \sigma_g h_g}{f_{g0}^2}$, 其中$h_g = 1100,f_{g0} = 10^6$。
给定功率谱密度，可以用带有均匀随机相位的频率混合来重现噪声。如已知相位噪声的功率谱密度$S_{\phi}(f)$,可以设置：
$\phi(t) = \sum_{j = 1}^{\infty} 2 \sqrt{S_{ \phi}(f_j) \Delta f} \cos (2\pi f_j t + \varphi_j )$
其中$\varphi_i$是从$[0,2\pi]$间均匀选取的随机变量。上述随机函数的导数为：
$\begin{align}
\frac{d\phi(t)}{dt} &= -\sum_{j = 1}^{\infty} 4\pi f_j \sqrt{S_{ \phi}(f_j) \Delta f} \sin (2\pi f_j t + \varphi_j ) \\
&= -\sum_{j = 1}^{\infty} 4\pi\sqrt{S_{ \delta\nu}(f_j) \Delta f} \sin (2\pi f_j t + \varphi_j ) 
\end{align}$
其中利用了关系：$S_{ \delta\nu}(f) = f^2 S_{ \phi}(f)$.
# 噪声的测量
### PDH直接测量
将PDH锁频误差信号接入频谱仪，即可实现对PDH锁后激光相噪的直接测量。原理如下：
PDH锁定点附近的误差信号近似为一条很陡的直线，其斜率与$\delta \nu$ 成正比。误差信号的斜率会随时间抖动，从中可以得到频率差关于时间的变化$\delta \nu(t)$.由于$R_\nu(\tau)=<\nu(t)\nu(t+\tau)>,S_\nu(f)=F(R_\nu(\tau))$,我们可以在频谱仪中读出相噪谱$S_\nu(f)$.
然而，由于误差信号的直线段很窄，我们只能读出$\delta \nu$很小时的噪声，即低频噪声。故这种方法一般不采用。
### Self-Heterodyne Spectrum
这种方法将信号分成两束，一束经过了$t_d$时间的延迟，一束经过了$\nu_s$的频率移动，接着二者干涉共同打在一个光电二极管上。光电二极管输出一个正比于光强的电流，通过分析这个电流的噪声功率谱，就可以反推出$S_\phi$.
### beat with PDH transmission signal
# 噪声的压制
## 滤波腔
由于腔的透射函数$T(w)$为洛伦兹线形，其线宽定义为腔的线宽$\Gamma = \frac{FSR}{F}$，所以腔可以看作一个滤波器，滤去入射光中$\Delta w > \Gamma$的部分。使用一个$F=3000$的腔，其线宽为$500kHz$, 可以滤掉$1MHz$以上的高频噪声。其缺点是腔的进光功率阈值较低(为$mW$量级)，在透射后光强会更小，因此常常需要进行注入锁定和光纤放大。
## PDH前馈系统
# ![802230031e6e4234b06e1ef3ba12cd6.png](https://cdn.nlark.com/yuque/0/2024/png/41004299/1705315300087-0f0dff7e-6263-4121-86b8-bd3b78e9d372.png#averageHue=%23fbf5f4&clientId=u2f9816db-30df-4&from=drop&height=395&id=u532aec9f&originHeight=441&originWidth=538&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=52001&status=done&style=none&taskId=u426c5f54-13c3-499f-9d87-d34f1cf293c&title=&width=481.3333435058594)
PDH前馈系统由一个相位延迟光纤，一个移相器(EOM)和一个P电路构成。
PDH前馈的理论推导详见:[https://arxiv.org/abs/2309.09759](https://arxiv.org/abs/2309.09759).
假设入射光含有$\varphi(t)$的相位噪声，前馈系统意图通过光纤的相位延迟来弥补这个相位噪声。PDH锁后的激光线宽远低于腔的线宽，而我们关心的高频相噪线宽远高于腔的线宽。在这个近似下，我们得到在锁定点附近的误差信号与$\varphi(t)$的关系:
$V_{err} \propto \varphi(t)$.
我们将误差信号接入一个P电路，并前馈到EOM，可以使EOM出射光产生额外的相位调制：
$E_{out} = E_0 exp(i(\omega_c t+ \varphi(t)+Gsin(\varphi(t')))$
调节参数使$G=-1,t'\approx t$,由于$|\varphi(t)|<<1$,我们便可以弥补相位噪声。论文中详细论证了这种方法对低频噪声的处理作用，并证明了它与滤波腔几乎等价。但对于高频噪声，一旦离开了$Im(R(w))$的近似直线段，且受限于调制EOM的带宽($\approx 20MHz$)，相噪就难以抑制。其相噪抑制效果图如下：

![70b823ee46948d25d0aeef69abdf75a.png](https://cdn.nlark.com/yuque/0/2024/png/41004299/1705317200527-d52d568a-86f6-4e52-a18f-1f29142462ca.png#averageHue=%23f9f6f5&clientId=u2f9816db-30df-4&from=drop&id=uf8e8b599&originHeight=487&originWidth=742&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=56202&status=done&style=none&taskId=u661fe556-c73f-45c9-8733-830100f3212&title=)
可见其对$2MHz$以上的高频噪声抑制效果不理想。








# 有相位噪声的单光子过程
在谐振条件下，有相位噪声的哈密顿量可以写为
$H = \frac{\hbar \Omega}{2} [e^{i\phi(t)} |e\rangle \langle g| + e^{-i\phi(t)} |g\rangle \langle e|]$
若使用含时酉变换： $U(t) = e^{-i\phi(t) |e\rangle \langle e|}$，新的基矢下的哈密顿量为：
$\begin{align}
H' &= i\hbar \frac{dU}{dt} U^\dagger + UHU^\dagger \\
&= \hbar \frac{d\phi}{dt} |e\rangle\langle e| + \frac{\hbar \Omega}{2} [ |e\rangle \langle g| + |g\rangle \langle e|] \\
 &= \frac{\hbar \Omega}{2} [ |e\rangle \langle g| + |g\rangle \langle e|] - \sum_{j = 1}^{\infty} 4\pi \hbar \sqrt{S_{\delta \nu}(f_j) \Delta f} \sin (2\pi f_j t + \varphi_j ) |e\rangle\langle e|
\end{align}$
其中利用了频率噪声的估计表达式。
我们求解：
$\begin{align}
H'/\hbar  &= \frac{1}{2} \Omega \sigma_x + \sum_{j = 1}^{\infty} 2\pi \sqrt{S_{\delta \nu}(f_j) \Delta f} \sin (2\pi f_j t + \varphi_j ) \sigma_z
\end{align}$
在$\frac{\sqrt{S_{\delta\nu}(f_i) \Delta f}}{ \Omega} := \delta_i \ll 1$的近似下，把误差部分视为微扰，在保留二阶的近似下，可以解析地给出上述哈密顿量的演化结果，详见文献[[链接]()]公式(74)

在模拟中，为了简化，我们设置初态为$\ket{g}$,激光作用使其在基态和激发态间震荡，误差为$\pi$pause后，测量坍缩到基态的概率。
```python
from qutip import *
import numpy as np
import matplotlib.pyplot as plt

#Function of PSD. para covers all parameters of this function 
def S_freq(f,para):
    h0 = para
    res = h0 
    return res

#Function generate the trace of the noise. 
# para covers all parameters of PSD function
#sumpara = [f0,fwidth,N] clearify the begin point of summontion f0, the summontion bandwidth fwidth, the fraction number N
def noise_coeff(t,args):
    phase_noise = 0
    phi_vec = args['phi']
    para = args['para']
    sumpara = args['sumpara']
    f0,fwidth,N = sumpara
    deltaf = fwidth / N
    #sum over the band wideth around point f0
    for i in range(N):
        f = f0 - fwidth/2 +deltaf*i
        PSD = S_freq(f,para)
        phase_noise = phase_noise + 2*np.pi*np.sqrt(PSD * deltaf) * np.sin((f)*2*np.pi*t + phi_vec[i])
    return phase_noise



Omega = 10**6 * 2* np.pi #Rabi frequency
time_scale =  np.pi/Omega
tau = 1*time_scale # simulation time
Delta = 0 # detuning
ptnum = 2 #time segment


# Sampling phase noise and phase noise parameter.
h0 = 1000 #Hz/Hz^2
simnum = 50

fwidth = 0.1*Omega/(2*np.pi) #Hz, the bandwidth of power spectrum of noise phase
N = 500 # cut noise bandwidth into N parts

x = np.linspace(0.01,9,80) 
hcenter_var = Omega * x /(2*np.pi)

plot_list = hcenter_var
error_list = np.zeros((len(plot_list),simnum))
mean_list = np.zeros(len(plot_list))
dev_list = np.zeros(len(plot_list))

for i in range(len(plot_list)):
    parameter = h0
    sumparameter = [plot_list[i],fwidth,N]
    #defined time-dependent Hamiltonian given sampled noise
    for j in range(simnum):
        phi_vec = 2*np.pi * np.random.random(size = N)
        args = {'phi':phi_vec,'para':parameter,'sumpara':sumparameter}
        H = [0.5 * Omega * sigmax(),[ sigmaz(),noise_coeff]] 
        time = np.linspace(0,tau,ptnum)
        psi0 = basis(2, 0)
        result = sesolve(H, psi0, time, args = args)
        
        #print error
        print(np.abs(result.states[-1][0,0])**2)
        error_list[i,j] = np.log10(np.abs(result.states[-1][0,0])**2)       
    
for i in range(len(plot_list)):
    mean_list[i] = np.mean(error_list[i])
    dev_list[i] = np.std(error_list[i])
print(error_list)

plt.errorbar(x,mean_list,yerr = dev_list, fmt = 'o')
plt.xlabel(r'$h_{center} /(\Omega/2\pi)$')
plt.ylabel(r'$log_{10}(error)$')
plt.title(r'$\pi$-Palse Error')
plt.show()

```
![whitenoise_translation.png](https://cdn.nlark.com/yuque/0/2024/png/40467816/1705286579815-54e77337-658e-4955-ad8c-1a36710553d0.png#averageHue=%23fbfbfb&clientId=u7d0b75ef-0575-4&from=drop&height=285&id=u5d913f1a&originHeight=480&originWidth=640&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=20791&status=done&style=none&taskId=uebf95c3c-9c36-45c5-805a-b54d0255593&title=&width=380)![Figure_2.png](https://cdn.nlark.com/yuque/0/2024/png/40467816/1705298565300-aa80c6ee-b69d-45b5-b920-d7d135da296a.png#averageHue=%23fbfbfb&clientId=u3254b533-af6d-4&from=drop&height=266&id=ue8fb3470&originHeight=480&originWidth=640&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=21290&status=done&style=none&taskId=u99f780f6-43e9-45dd-9a11-2f087bbf8b7&title=&width=355)
上图是固定宽度高度的白噪声在有不同起始点$f_0$时噪声带来的误差。其中纵轴是 $10\times log_{10}(p \times 1000)$，是dBm的单位。横轴是$2\pi f_0/ \Omega$ ,$f_0$是白噪声起始点,区间为 $[f_0, f_0+10^5Hz]$, $h0 = 1000Hz$, $\Omega = 2\pi *10^6 Hz$。随着分布逐渐靠向高频噪声，误差在震荡地减小。
更真实的噪声分布具有如下的函数形式，它由一段白噪声和随后的洛伦兹线形的噪声拼接而成
$\begin{align}
S_{\delta \nu}(f) = \left\{
\begin{aligned}
&h_0, \quad  f < f_0\\
&\frac{h_L}{1 + (\frac{fF}{1.5 \times 10^9})^2}, \quad f > f_0
\end{aligned}
\right.
\end{align}$
设置参数$\Omega = 2\pi \times 10^6,  F \in (0.003,0.05) \times \frac{\Omega}{2\pi}$,固定$f_0 = 5 \times 10^5Hz, h_L  = 3000 Hz/Hz^2,  h_0 = 100 Hz^2/Hz$,作图如下
![F/(Omega/2pi) = 0.0003](https://cdn.nlark.com/yuque/0/2024/png/40467816/1705301657579-81ea15ac-2148-4f84-9b29-ec6a13fa7695.png#averageHue=%23fbfbfb&clientId=u3254b533-af6d-4&from=drop&height=245&id=u66a6d155&originHeight=480&originWidth=640&originalType=binary&ratio=1.25&rotation=0&showTitle=true&size=22126&status=done&style=none&taskId=uf94b145b-aad3-44c6-a331-739cddaa314&title=F%2F%28Omega%2F2pi%29%20%3D%200.0003&width=326 "F/(Omega/2pi) = 0.0003")![F/(Omega/2pi) = 0.05](https://cdn.nlark.com/yuque/0/2024/png/40467816/1705301665598-ad4d5ea4-6dde-459f-810c-70d87228acf2.png#averageHue=%23fcfcfc&clientId=u3254b533-af6d-4&from=drop&height=243&id=u6f785e9f&originHeight=480&originWidth=640&originalType=binary&ratio=1.25&rotation=0&showTitle=true&size=12321&status=done&style=none&taskId=u325602f6-08e0-43ed-baae-50d3cbfc974&title=F%2F%28Omega%2F2pi%29%20%3D%200.05&width=324 "F/(Omega/2pi) = 0.05")
![realnoise1.png](https://cdn.nlark.com/yuque/0/2024/png/40467816/1705301681286-29193662-ba36-4449-9d4a-3a1611b08ccc.png#averageHue=%23fbfbfb&clientId=u3254b533-af6d-4&from=drop&height=326&id=u673b54ec&originHeight=480&originWidth=640&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=20626&status=done&style=none&taskId=ue85a3bcf-72ed-4313-a7a0-5a714a2a1fe&title=&width=434)

设置参数$\Omega = 2\pi \times 10^6,  f_0 \in (0.5,5) \times \frac{\Omega}{2\pi}$,固定:$F = 10^4Hz, h_L  = 3000 Hz/Hz^2,  h_0 = 100 Hz^2/Hz$,
作图如下
![f0/(Omega/2pi) = 0.5](https://cdn.nlark.com/yuque/0/2024/png/40467816/1705302266050-afab3e04-7631-4c29-84a5-c1f42cae87c5.png#averageHue=%23fbfbfb&clientId=u3254b533-af6d-4&from=drop&height=267&id=ue4f71c27&originHeight=480&originWidth=640&originalType=binary&ratio=1.25&rotation=0&showTitle=true&size=23546&status=done&style=none&taskId=uda147453-f70e-4aa1-a342-134f2e5f14a&title=f0%2F%28Omega%2F2pi%29%20%3D%200.5&width=356 "f0/(Omega/2pi) = 0.5")![f0/(Omega/2pi) = 0.5](https://cdn.nlark.com/yuque/0/2024/png/40467816/1705302271074-73d4b07e-e16a-423c-ad1b-40a270dce3bf.png#averageHue=%23fbfbfb&clientId=u3254b533-af6d-4&from=drop&height=260&id=u963558ce&originHeight=480&originWidth=640&originalType=binary&ratio=1.25&rotation=0&showTitle=true&size=17556&status=done&style=none&taskId=u9655dde9-485e-4374-b43e-cf50ee4a8a8&title=f0%2F%28Omega%2F2pi%29%20%3D%200.5&width=346 "f0/(Omega/2pi) = 0.5")
![Figure_1.png](https://cdn.nlark.com/yuque/0/2024/png/40467816/1705302686714-bc161a1c-0626-44a3-98ae-11cd9121f280.png#averageHue=%23fbfbfb&clientId=u3254b533-af6d-4&from=drop&height=300&id=u895b3fb1&originHeight=480&originWidth=640&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=17731&status=done&style=none&taskId=u1df61814-dd08-4789-9d45-5fab54645fa&title=&width=400)

此外，除了激光本身的相位抖动，原子本身还有随机的速度，速度的概率分布依赖于原子的温度，有如下函数形式:
$f(v) =\frac{1}{\sqrt{2 \pi} v_{th}} e^{\frac{v^2}{2 v_{th}^2}}$
由于多普勒效应，随机的速度将给激光带来随机的detuning，我们也可以模拟这个噪声带来的影响
[待续]
# 双光子过程中的噪声
按照同样的方式模拟三能级系统，可以处理拉曼双光子过程
[待续]
此外，还可将中间态decay的影响考虑在内
[待续]
# 附录1：Servo Bump形式的噪声模拟
为了验证代码的正确性，我们复现论文[5]中的模拟。
下面的代码绘制噪声大小随着 servo bump形式噪声中的$f_g$参数的变化
```python
from qutip import *
import numpy as np
import matplotlib.pyplot as plt

def S_servo_freq(f,para):
    [h0,sg,fg,sigmag] = para
    res = h0 + (sg *(fg)*(fg))/(np.sqrt(8*np.pi)*sigmag)* np.exp(-((f - fg)**2)/(2*sigmag**2)) 
    #+ hg* np.exp(-((f + fg)**2)/(2*sigmag**2))
    return res

def noise_coeff(t,args):
    phi_vec = args['phi']
    para = args['para']
    [h0,hg,fg,sigmag] = para
    freq_noise = 0
    for i in range(N):
        f = fg - fwidth/2 + deltaf*i
        PSD = S_servo_freq(f,para)
        freq_noise = freq_noise + 2*np.pi*np.sqrt(PSD * deltaf) * np.sin(f*2*np.pi*t + phi_vec[i])
    return freq_noise

Omega = 10**6 * 2* np.pi #Rabi frequency
time_scale =  np.pi/Omega
tau = 2*time_scale # simulation time
Delta = 0 # detuning
ptnum = 2 #time segment


# Sampling phase noise and phase noise parameter.
h0 = 0 #Hz/Hz^2

sigmag = 1400  #sigmag/Omega
hg = 1100
fg0 = 10**6
sg = np.sqrt(8*np.pi) * sigmag * hg /(fg0*fg0)

simnum = 30


fwidth = 4*sigmag #Hz, the bandwidth of power spectrum of noise phase
N = 500 # cut noise bandwidth into N parts
deltaf = fwidth / N



x = np.linspace(0.01,4,40) 
fg_var = Omega * x /(2*np.pi)

plot_list = fg_var
error_list = np.zeros((len(plot_list),simnum))
mean_list = np.zeros(len(plot_list))
dev_list = np.zeros(len(plot_list))

for i in range(len(plot_list)):
    parameter = [h0,sg,plot_list[i],sigmag]

    #defined time-dependent Hamiltonian given sampled noise
    for j in range(simnum):
        phi_vec = 2*np.pi * np.random.random(size = N)
        args = {'phi':phi_vec,'para':parameter}
        H = [0.5 * Omega * sigmax(),[ sigmaz(),noise_coeff]] 
        time = np.linspace(0,tau,ptnum)
        psi0 = basis(2, 0)
        result = sesolve(H, psi0, time, args = args)
        
        #print error
        print(np.abs(result.states[-1][1,0])**2)
        error_list[i,j] = np.log10(np.abs(result.states[-1][1,0])**2)       
    
for i in range(len(plot_list)):
    mean_list[i] = np.mean(error_list[i])
    dev_list[i] = np.std(error_list[i])
print(error_list)

plt.errorbar(x,mean_list,yerr = dev_list, fmt = 'o')
plt.xlabel(r'$fg /(\Omega/2\pi)$')
plt.ylabel(r'$log_{10}(error)$')
plt.title(r'$2\pi$-Palse Error')
plt.show()
```
设定初态处于基态，在一个$\pi-$Palse和$2\pi-$Palse过程后，分别衡量末态处于激发态和基态的概率。在无噪声时二者应当严格为0，故这个值可以衡量噪声的大小。
下面是模拟servo bump噪声的结果以及和文献结果的对比。横轴为高斯型噪声的中心，纵轴是噪声的大小（的对数）。上两图是$\pi$Pulse和$2\pi$Pulse的结果下面两图是对应文献中的结果，可见有类似的形状。模拟代码见上。
![Figure_1.png](https://cdn.nlark.com/yuque/0/2024/png/40467816/1705284121163-7096c447-a8ef-4083-9a36-1d48d2574e67.png#averageHue=%23fbfbfb&clientId=ub53574f0-2a9e-4&from=drop&height=245&id=uc3546c1a&originHeight=480&originWidth=640&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=16762&status=done&style=none&taskId=ua8617a69-12dd-473a-b41e-b7f9ee09f76&title=&width=327)![Figure_2.png](https://cdn.nlark.com/yuque/0/2024/png/40467816/1705284168855-cc942690-fb05-405f-8fda-ba4eaf955dcc.png#averageHue=%23fbfbfb&clientId=ub53574f0-2a9e-4&from=drop&height=263&id=u386fc6a6&originHeight=480&originWidth=640&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=17406&status=done&style=none&taskId=u5389d978-80a7-4f18-8397-6026081778b&title=&width=350)
![45804b3efd53d8a839d364cd35e3e54.png](https://cdn.nlark.com/yuque/0/2024/png/40467816/1705214550584-2f38b00e-b219-4aa3-b902-ae31f27ed22f.png#averageHue=%23f7f0f2&clientId=uad779efb-02c4-4&from=drop&height=248&id=u4a3c90d6&originHeight=317&originWidth=409&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=18951&status=done&style=none&taskId=u5f4e7ee8-6268-4de3-afeb-cd47b881c2b&title=&width=320)![2973a8eaff5c1966e9c47fb41f41ce0.png](https://cdn.nlark.com/yuque/0/2024/png/40467816/1705214559504-14b9e66b-55ae-4003-9872-694b0b5566fb.png#averageHue=%23f6f3f3&clientId=uad779efb-02c4-4&from=drop&height=272&id=u096a1546&originHeight=339&originWidth=379&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=26430&status=done&style=none&taskId=u812ba8f5-f2e6-4ebe-bfdf-3450b8baeb1&title=&width=304)


## 附录2：更高效的噪声拉比振荡模拟方式
用qutip模拟多个时间分段的过程十分耗时，我们考虑直接手撸解薛定谔方程
```python
import numpy as np
from scipy.linalg import expm
import matplotlib.pyplot as plt
%matplotlib qt5

# Sampling phase noise and phase noise parameter.单位为Hz
Omega = 1e6 * 2* np.pi #Rabi frequency
h0 = 0 #Hz/Hz^2
#单位:Hz
sigmag = 1400  #sigmag/Omega
hg = 1100
fg0 = 1e6
sg = 10*np.sqrt(8*np.pi) * sigmag * hg /(fg0*fg0)

simnum = 5

fwidth = 4*sigmag #Hz, the bandwidth of power spectrum of noise phase
N = 500 # cut noise bandwidth into N parts
deltaf = fwidth / N



def S_servo_freq(f,para):
    [h0,sg,fg,sigmag] = para
    res = h0 + (sg *(fg)*(fg))/(np.sqrt(8*np.pi)*sigmag)* np.exp(-((f - fg)**2)/(2*sigmag**2)) 
    #+ hg* np.exp(-((f + fg)**2)/(2*sigmag**2))
    return res

def noise_coeff(t,args):
    phi_vec = args['phi']
    para = args['para']
    [h0,hg,fg,sigmag] = para
    freq_noise = 0
    for i in range(N):
        f = fg - fwidth/2 + deltaf*i
        PSD = S_servo_freq(f,para)
        freq_noise += 2*np.pi*np.sqrt(PSD * deltaf) * np.sin(f*2*np.pi*t + phi_vec[i])
    return freq_noise

# 1. 定义哈密顿量

def H(t, args):
    sigma_z = np.array([[1, 0], [0, -1]])
    sigma_x = np.array([[0, 1], [1, 0]])
    
    return 0.5 * Omega * sigma_x + noise_coeff(t, args) * sigma_z

# 2. 定义初始状态psi_0为基态
psi_0 = np.array([1, 0])


# 3. 定义时间演化函数evolution(psi,args)
def evolution(psi, H, dt):
    return np.dot(expm(-1j * H * dt), psi)

# 4. 在时间步长下求解薛定谔方程(求解4pi pulse即可)
dt = 0.1/Omega
npulse = 20
t = np.arange(0, npulse*2*np.pi/Omega, dt)
mean_P = np.zeros(len(t))
error_P = np.zeros(len(t))
parameter = [h0,sg,fg0,sigmag] 
for j in range(simnum):
    phi_vec = 2*np.pi * np.random.random(size = N)
    args = {'phi':phi_vec,'para':parameter} 
    psi_t = np.zeros((len(t), 2), dtype=complex)
    psi_t[0] = psi_0
    #求解哈密顿方程
    for i in range(1, len(t)):
        H_delta = H(t[i], args)
        print(H_delta)
        psi_t[i] = evolution(psi_t[i-1], H_delta, dt)
    
    # 5. 画出激发态概率随时间的变化曲线
    P_excited = np.abs(psi_t[:, 1])**2
    plt.plot(t, P_excited, linewidth = 2.0, color = 'r')#, label=f'delta={delta:.2f}')
    mean_P += P_excited
    
mean_P /= simnum
plt.plot(t, mean_P, linewidth = 2.0, color = 'k')
plt.xlabel('Time')
plt.ylabel('Excited state probability')
plt.legend()
plt.show()

```

模拟30次20个$2\pi$pulse下的拉比振荡图像如下：![2d4a4f219aab046fb13c7a63990a0d9.png](https://cdn.nlark.com/yuque/0/2024/png/41004299/1705305021012-cedc2e34-47b0-4a54-8ef4-8bf9fdb1cc5f.png#averageHue=%23dacaca&clientId=uce7e5149-bcca-4&from=drop&id=u695d1251&originHeight=690&originWidth=903&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=185638&status=done&style=none&taskId=u71780cd1-e02d-4959-b7e1-87560bc543e&title=)
## 
```python
# 导入必要的库
import numpy as np
import matplotlib.pyplot as plt
from scipy.linalg import expm
%matplotlib qt5

# Sampling phase noise and phase noise parameter.单位为Hz
Omega = 10**6 * 2* np.pi #Rabi frequency
h0 = 1000 #Hz/Hz^2
h_center = Omega/(2*np.pi)

simnum = 50
fwidth = 0.1*Omega/(2*np.pi) #Hz, the bandwidth of power spectrum of noise phase
N = 500 # cut noise bandwidth into N parts
deltaf = fwidth / N




#Function of PSD. para covers all parameters of this function 
def S_freq(f,para):
    h0 = para
    res = h0 
    return res

#Function generate the trace of the noise. 
# para covers all parameters of PSD function
#sumpara = [f0,fwidth,N] clearify the begin point of summontion f0, the summontion bandwidth fwidth, the fraction number N
def noise_coeff(t,args):
    phase_noise = 0
    phi_vec = args['phi']
    para = args['para']
    sumpara = args['sumpara']
    f0,fwidth,N = sumpara
    deltaf = fwidth / N
    #sum over the band wideth around point f0
    for i in range(N):
        f = f0 - fwidth/2 +deltaf*i
        PSD = S_freq(f,para)
        phase_noise = phase_noise + 2*np.pi*np.sqrt(PSD * deltaf) * np.sin((f)*2*np.pi*t + phi_vec[i])
    return phase_noise

# 1. 定义哈密顿量

def H(t, args):
    sigma_z = np.array([[1, 0], [0, -1]])
    sigma_x = np.array([[0, 1], [1, 0]])
    
    return 0.5 * Omega * sigma_x + noise_coeff(t, args) * sigma_z

# 2. 定义初始状态psi_0为基态
psi_0 = np.array([1, 0])


# 3. 定义时间演化函数evolution(psi,args)
def evolution(psi, H, dt):
    return np.dot(expm(-1j * H * dt), psi)

# 4. 在时间步长下求解薛定谔方程(求解4pi pulse即可)
dt = 0.1/Omega
npulse = 15
t = np.arange(0, npulse*2*np.pi/Omega, dt)
mean_P = np.zeros(len(t))
error_P = np.zeros(len(t))

parameter = h0
sumparameter = [h_center,fwidth,N]
for j in range(simnum):
    phi_vec = 2*np.pi * np.random.random(size = N)
    args = {'phi':phi_vec,'para':parameter,'sumpara':sumparameter}
    psi_t = np.zeros((len(t), 2), dtype=complex)
    psi_t[0] = psi_0
    #求解哈密顿方程
    for i in range(1, len(t)):
        H_delta = H(t[i], args)
        print(H_delta)
        psi_t[i] = evolution(psi_t[i-1], H_delta, dt)
    
    # 5. 画出激发态概率随时间的变化曲线
    P_excited = np.abs(psi_t[:, 1])**2
    plt.plot(t, P_excited, linewidth = 2.0, color = 'r')#, label=f'delta={delta:.2f}')
    mean_P += P_excited
    
mean_P /= simnum
plt.plot(t, mean_P, linewidth = 2.0, color = 'k')
plt.xlabel('Time')
plt.ylabel('Excited state probability')
plt.legend()
plt.show()
```
以下是进行50次模拟15个$2\pi$ pulse的拉比振荡图($h_{center} = \frac{\Omega}{2\pi}$)：
![3882de006813e1c2e34a3f934e1f192.png](https://cdn.nlark.com/yuque/0/2024/png/41004299/1705310617285-2c5a9902-0b78-4c97-9deb-5903024993bf.png#averageHue=%23e1cdcd&clientId=uf9fe7fd5-e984-4&from=drop&id=ua4c260d7&originHeight=675&originWidth=874&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=170919&status=done&style=none&taskId=u10cd9d5d-ec0c-446e-bf77-714fb4be3b8&title=)

# 附录3：总代码
```python
from qutip import *
import numpy as np
import matplotlib.pyplot as plt

#Function of PSD. para covers all parameters of this function 
def S_white(f,para):
    '''
    white noise with width 'fwidth', intensity 'h0', frequncy begin point 'fbegin'
    para = [h0,fwidth,fbegin]
    '''
    [h0,fwidth,fbegin] = para
    if fbegin <= f <= fbegin+fwidth:
        res = h0 
    else:
        res = 0
    return res

def S_real(f,para):
    '''
    Lorentz line + white noise
    para = [h0,hL,F,f0]
    '''
    [h0,hL,F,f0] = para
    if f<f0:
        res = h0 
    else:
        res = hL/(1 + (f*F/(1.5*10**9))**2)
    return res

def S_servo_freq(f,para):
    [h0,sg,fg,sigmag] = para
    res = h0 + (sg *(fg)*(fg))/(np.sqrt(8*np.pi)*sigmag)* np.exp(-((f - fg)**2)/(2*sigmag**2)) 
    #+ hg* np.exp(-((f + fg)**2)/(2*sigmag**2))
    return res

def noise_coeff(t,args):
    '''
    Function generate the trace of the noise. 
    args includes ['phi','para','sumpara','Sfun']

    'Sfun' is the function of PSD with input [f,para]
    'para' covers all parameters of PSD function
    'sumpara' = [f0,fwidth,N] clearify the center point of summontion f0, the summontion bandwidth fwidth, the fraction number N
    'phi' is phase that used to be random sampled from [0,2pi] 
    '''
    phase_noise = 0
    phi_vec = args['phi']
    para = args['para']
    sumpara = args['sumpara']
    Sfun = args['Sfun']
    f0,fwidth,N = sumpara
    deltaf = fwidth / N
    #sum over the band wideth around point f0
    for i in range(N):
        f = f0 - fwidth/2 +deltaf*i
        PSD = Sfun(f,para)
        phase_noise = phase_noise + 2*np.pi*np.sqrt(PSD * deltaf) * np.sin((f)*2*np.pi*t + phi_vec[i])
    return phase_noise


def noise_para_plot(process_para,Sfun,PSD_para,Plotchoice,Plotrange,sumpara,simnum):
    '''
    process_para:
    process_para = [Omega,q], Omega is the Rabi frequency, q means we check the noise of q-\pi Palse process result.
    
    Sfun:
    Function of PSD, with input [f, para]
    
    PSD_para: 
    The parameter input into Sfun. Order is the same with para
    
    Plotchoice: 
    integer, for Plotchoice = 0, plot the 1-th parameter in PSD_para
    
    Plotrange: 
    Plotrange =  np.linspace(begin,end,plotsegment),  
    Plotrange* Omega /(2*np.pi) will be the plotrange of parameter
    
    sumpara: 
    has the same shape of Plotrange. sumpara[i] =[fcenter,fwidth,N] 
    Allow changing summontion range to [fcenter - fwidth/2, fcenter + fwidth/2]* Omega /(2*np.pi)
    with N segments when parameter changes

    simnum: 
    Simulation numbers
    '''

    [Omega, q] = process_para
    time_scale =  np.pi/Omega
    tau = q *time_scale # simulation time
    index = int((1+(-1)**q)*0.5)
    ptnum = 2 #time segment

    plot_list = Omega * Plotrange /(2*np.pi)
    error_list = np.zeros((len(plot_list),simnum))
    mean_list = np.zeros(len(plot_list))
    dev_list = np.zeros(len(plot_list))

    for i in range(len(plot_list)):
        PSD_para[Plotchoice] = plot_list[i]
        sumparameter = sumpara[i]
        N = sumparameter[-1]
        #defined time-dependent Hamiltonian given sampled noise
        for j in range(simnum):
            phi_vec = 2*np.pi * np.random.random(size = N)
            args = {'phi':phi_vec,'para':PSD_para,'sumpara':sumparameter,'Sfun':Sfun}
            H = [0.5 * Omega * sigmax(),[ sigmaz(),noise_coeff]] 
            time = np.linspace(0,tau,ptnum)
            psi0 = basis(2, 0)
            result = sesolve(H, psi0, time, args = args)
            
            #print error
            print(np.abs(result.states[-1][index,0])**2)
            error_list[i,j] = np.log10(np.abs(result.states[-1][index,0])**2)       
        
    for i in range(len(plot_list)):
        mean_list[i] = np.mean(error_list[i])
        dev_list[i] = np.std(error_list[i])
    print(error_list)

    plt.errorbar(Plotrange,mean_list,yerr = dev_list, fmt = 'o')
    plt.xlabel(r'$parameter /(\Omega/2\pi)$')
    plt.ylabel(r'$log_{10}(error)$')
    plt.title( r'%s $\pi$-Palse Error'%q)
    plt.show()

def PSD_plot(PSD,plotrange,para):
    '''
    This function visually show the shape of PSD function
    PSD: Noise function
    para:parameter of the PSD function
    plotrange: list of [begin point, end point]
    '''
    [begin, end] = plotrange
    plotseg = 1000
    x = np.linspace(begin,end,plotseg)
    y = np.zeros(plotseg)
    for i in range(plotseg):
        y[i] = PSD(x[i],para)
    plt.plot(x,y)
    plt.xlabel('f')
    plt.ylabel(r'$\S_{\delta \nu}(f)$')
    plt.title('parameter = [%s]'%para)
    plt.show()

def decay_plot(PSD,PSD_para,simnum,sumparameter,plot_para):
    '''
    PSD: Function of PSD

    PSD_para: parameters of PSD

    simnum:simulation time

    plot_para:[Omega,N,ptnum ]
    Omega:Rabi
    N : N-pi pulse
    ptnum = time segments

    sumparameter = [f0,fwidth,N] 
    clearify the center point of summontion f0, the summontion bandwidth fwidth, the fraction number N
    '''
    Omega,q,ptnum = plot_para
    tau = q*np.pi/Omega
    index = int((1+(-1)**q)*0.5)
    p = np.zeros((simnum,ptnum))
#defined time-dependent Hamiltonian given sampled noise
    for j in range(simnum):
        N = sumparameter[-1]
        phi_vec = 2*np.pi * np.random.random(size = N)
        args = {'phi':phi_vec,'para':PSD_para,'sumpara':sumparameter,'Sfun':PSD}
        H = [0.5 * Omega * sigmax(),[ sigmaz(),noise_coeff]] 
        time = np.linspace(0,tau,ptnum)
        psi0 = basis(2, 0)
        result = sesolve(H, psi0, time, args = args)
        print(np.abs(result.states[-1][index,0])**2)
            
       #Plot Prob(ground state) changed with time
        for i in range(ptnum):
            p[j,i] = np.abs(result.states[i][0,0])**2
    
    plt.figure()
    plt.grid()
    for j in range(simnum):
        plt.plot(time,p[j],label = r'$|g \rangle$')
    plt.show()
        
def main1():
    #Plot decay pic
    Omega = 10**6 * 2* np.pi #Rabi frequency
    q = 30
    ptnum = 100
    plot_para = Omega,q,ptnum

    h0 = 0
    sigmag = 1400  #sigmag/Omega
    hg = 1100
    fg0 = 10**6
    sg = np.sqrt(8*np.pi) * sigmag * hg /(fg0*fg0) *100
    fg = Omega /(2*np.pi)
    PSD_para = [h0,sg,fg,sigmag]

    simnum = 10

    sumpara = [fg, 4*sigmag,500]

    decay_plot(S_servo_freq,PSD_para,simnum,sumpara,plot_para)

def main2():
    Omega = 10**6 * 2* np.pi #Rabi frequency
    q = 1
    process_para = [Omega, q]

    h0 = 100
    hL = 3000
    F = 10000
    f0 = 5*10**5
    PSD_para = [h0,hL,F,f0]
    Plotchoice = 3
    N = 50
    Plotrange = np.linspace(0.5,5,N) 

    fwidth =  4*f0
    sumpara = [[2*f0, fwidth ,500] for t in range(N)]

    simnum = 30
    #You can use PSD_plot to visually choose the best sum range of frequency
    PSD_plot(S_real,[0,fwidth],PSD_para)
    noise_para_plot(process_para, S_real , PSD_para , Plotchoice , Plotrange , sumpara , simnum)

    

if __name__ == '__main__':
    main2()
```
# 
## 相关资料
> [1].Pascal Scholl, **Simulation quantique de modèles de spins avec des grandes matrices d’atomes de Rydberg :**[https://theses.hal.science/tel-03523082/](https://theses.hal.science/tel-03523082/)  
> **（Browaeys组的博士论文）**

> [2].Antoine Browaeys et al.,  **Analysis of imperfections in the coherent optical excitation of single atoms to Rydberg states: **[**https://arxiv.org/abs/1802.10424**](https://arxiv.org/abs/1802.10424)

> [3].Harry Levine et al., **High-fidelity control and entanglement of Rydberg atom qubits:**
> [**https://arxiv.org/abs/1806.04682**](https://arxiv.org/abs/1806.04682)

> [4].Jan Hald and Valentina Ruseva,** Efficient suppression of diode-laser phase noise by optical filtering: **[**https://opg.optica.org/josab/abstract.cfm?uri=josab-22-11-2338**](https://opg.optica.org/josab/abstract.cfm?uri=josab-22-11-2338)
> **（理论计算滤波腔抑制相位噪声）**

> [5].X. Jiang, J. Scott, Mark Friesen, and M. Saffman, **Sensitivity of quantum gate fidelity to laser phase and intensity noise**
> [**https://journals.aps.org/pra/abstract/10.1103/PhysRevA.107.042611**](https://journals.aps.org/pra/abstract/10.1103/PhysRevA.107.042611)
> 



